---
alwaysApply: true
---

# Deco MCP Template Development Guide

## Project Overview

This is a **Deco MCP (Model Context Protocol) server** template with a **React + Tailwind CSS frontend**. It provides a full-stack development environment where:
- The `/server` folder contains the MCP server (Cloudflare Workers + Deco runtime)
- The `/view` folder contains the React frontend (Vite + Tailwind CSS)
- The server serves both MCP endpoints AND the built frontend assets

## Goal

The goal of this template is to help users generate their apps with data schemas and tools, using AI and third-party API via our RPC framework (check deco.gen.ts).

After this template is initiated, the user will give you prompt to create a new application.

**Required:** Modify README.md and SEO props (in index.html) for the app as soon as you know the app's intent. We shouldn't deploy applications with the same README and title, description of the template.

## Project Structure

```
react-tailwind-view/
â”œâ”€â”€ package.json          # Root workspace with dev/gen/deploy scripts
â”œâ”€â”€ server/               # MCP Server (Cloudflare Workers + Deco)
â”‚   â”œâ”€â”€ main.ts          # Main server entry point
â”‚   â”œâ”€â”€ deco.gen.ts      # Generated types for integrations
â”‚   â”œâ”€â”€ tools/           # Domain-organized tools (max 300 lines per file)
â”‚   â”‚   â”œâ”€â”€ index.ts     # Central export point for all tools
â”‚   â”‚   â”œâ”€â”€ todos.ts     # Todo-related tools
â”‚   â”‚   â”œâ”€â”€ user.ts      # User-related tools
â”‚   â”‚   â””â”€â”€ [domain].ts  # Additional domain-specific tools
â”‚   â”œâ”€â”€ wrangler.toml    # Cloudflare Workers config
â”‚   â””â”€â”€ package.json     # Server dependencies
â””â”€â”€ view/                # React Frontend (Vite + Tailwind)
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ main.tsx     # React app entry point
    â”‚   â”œâ”€â”€ lib/rpc.ts   # RPC client for server communication
    â”‚   â”œâ”€â”€ hooks/       # TanStack Query hooks for RPC calls
    â”‚   â”œâ”€â”€ routes/      # React Router routes
    â”‚   â””â”€â”€ components/  # UI components
    â”œâ”€â”€ package.json     # Frontend dependencies
    â””â”€â”€ vite.config.ts   # Vite configuration
```

## Development Workflow

### Root Commands (npm workspace)
- `npm run dev` - **Primary development command**
  - Starts frontend build in watch mode
  - Starts MCP server on port 8787
  - Server serves both API endpoints + frontend assets
  - Hot reload for both frontend and backend
  
- `npm run gen` - **Type generation**
  - Generates TypeScript types for deco integrations
  - Creates `server/deco.gen.ts` with typed RPC interfaces
  - Run this after adding new integrations in deco.chat

- `npm run gen:self` - **Self-type generation for your own tools**
  - Generates TypeScript types for your own server's tools
  - Requires the server to be running (`npm run dev`)
  - Copy the development URL from server logs (e.g., "https://localhost-48d64e92.deco.host")
  - Add /mcp to the path. So, for the URL https://localhost-48d64e92.deco.host you should set DECO_SELF_URL as https://localhost-48d64e92.deco.host/mcp.
  - Run: `DECO_SELF_URL=<your-dev-url> npm run gen:self`
  - Creates typed RPC interfaces for your own tools
  - Run this after adding new tools to your server

- `npm run deploy` - **Production deployment**
  - Builds frontend for production
  - Deploys to Cloudflare Workers
  - Makes app available at public URL

### Server Architecture (`/server`)

**Key Files:**
- `main.ts` - Main server with tools and asset serving
- `deco.gen.ts` - Generated types for integrations (auto-generated)
- `wrangler.toml` - Cloudflare Workers config with asset binding

**Server Pattern:**
```typescript
// server/main.ts structure
import { withRuntime } from "@deco/workers-runtime";
import { createPrivateTool } from "@deco/workers-runtime/mastra";

// 1. Define tools (functions the MCP can call) - Use createPrivateTool by default
const createMyTool = (env: Env) => createPrivateTool({
  id: "MY_TOOL",
  description: "Tool description",
  inputSchema: z.object({ /* input schema */ }),
  outputSchema: z.object({ /* output schema */ }),
  execute: async ({ context }) => {
    // Tool logic here
    return { /* result */ };
  },
});

// 2. Setup runtime with fallback to serve frontend
const runtime = withRuntime<Env>({
  tools: [createMyTool],
  fetch: fallbackToView("/"), // Serves frontend assets
});

export default runtime;
```

### Frontend Architecture (`/view`)

**Key Files:**
- `src/main.tsx` - React app entry with TanStack Router setup
- `src/lib/rpc.ts` - RPC client for server communication
- `src/routes/` - TanStack Router routes
- `src/components/` - UI components with Tailwind CSS

**Frontend-to-Server Communication:**
```typescript
// view/src/lib/rpc.ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

**Best Practice: Use TanStack Query Hooks for RPC Calls**

**âŒ Avoid calling RPC client directly in components:**
```typescript
// DON'T DO THIS - Direct RPC calls in components
function MyComponent() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    client.MY_TOOL({ name: "example" }).then(setData);
  }, []);
  
  return <div>{data?.result}</div>;
}
```

**âœ… Recommended: Wrap RPC calls with TanStack Query hooks:**
```typescript
// view/src/hooks/useMyTool.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// For read operations - use useQuery
export const useMyTool = (input: { name: string }) => {
  return useQuery({
    queryKey: ["myTool", input],
    queryFn: () => client.MY_TOOL(input),
    enabled: !!input.name, // Only run when input is valid
  });
};

// For write operations - use useMutation
export const useMyToolMutation = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (input: { name: string }) => client.MY_TOOL(input),
    onSuccess: () => {
      // Invalidate related queries after successful mutation
      queryClient.invalidateQueries({ queryKey: ["myTool"] });
    },
  });
};

// Usage in components:
function MyComponent() {
  const { data, isLoading, error } = useMyTool({ name: "example" });
  const myToolMutation = useMyToolMutation();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <p>Result: {data?.result}</p>
      <button 
        onClick={() => myToolMutation.mutate({ name: "new-example" })}
        disabled={myToolMutation.isPending}
      >
        {myToolMutation.isPending ? "Running..." : "Run Tool"}
      </button>
    </div>
  );
}
```

**TanStack Router Pattern:**
```typescript
// view/src/routes/my-route.tsx
import { createRoute, type RootRoute } from "@tanstack/react-router";

function MyRouteComponent() {
  return (
    <div>
      <h1>My Route</h1>
      {/* Component content */}
    </div>
  );
}

// Export function that creates the route
export default (parentRoute: RootRoute) =>
  createRoute({
    path: "/my-route",
    component: MyRouteComponent,
    getParentRoute: () => parentRoute,
  });

// Add to main.tsx router tree:
import MyRoute from "./routes/my-route.tsx";

const routeTree = rootRoute.addChildren([
  indexRoute,
  MyRoute(rootRoute),
  // ... other routes
]);
```

**Navigation Best Practices:**

Use TanStack Router's type-safe navigation components and hooks for internal navigation:

```typescript
import { Link, useNavigate } from "@tanstack/react-router";

function NavigationExamples() {
  const navigate = useNavigate();

  const handleProgrammaticNavigation = () => {
    // Type-safe programmatic navigation
    navigate({ to: "/my-route" });
    
    // With search params
    navigate({ 
      to: "/my-route", 
      search: { filter: "active" } 
    });
    
    // With route params
    navigate({ 
      to: "/users/$userId", 
      params: { userId: "123" } 
    });
  };

  return (
    <div>
      {/* âœ… Use Link for internal navigation */}
      <Link to="/my-route">Go to My Route</Link>
      
      {/* âœ… Link with search params */}
      <Link to="/my-route" search={{ filter: "active" }}>
        Filtered Route
      </Link>
      
      {/* âœ… Link with route params */}
      <Link to="/users/$userId" params={{ userId: "123" }}>
        User Profile
      </Link>
      
      {/* âœ… External links use regular anchor tags */}
      <a href="https://external-site.com" target="_blank" rel="noopener noreferrer">
        External Link
      </a>
      
      {/* âœ… Programmatic navigation */}
      <button onClick={handleProgrammaticNavigation}>
        Navigate Programmatically
      </button>
    </div>
  );
}
```

**âŒ Avoid using anchor tags for internal navigation:**
```typescript
// DON'T DO THIS for internal routes
<a href="/my-route">Internal Link</a>

// This loses type safety and doesn't work with TanStack Router's features
```

**Navigation Guidelines:**
- Use `<Link>` component for internal route navigation with full type safety
- Use `useNavigate()` hook for programmatic navigation (form submissions, button clicks, etc.)
- Only use `<a>` tags for external links (different domains, mailto:, tel:, etc.)
- TanStack Router provides compile-time route validation and autocompletion

## Development Best Practices

### When Adding New Tools:
1. **Plan first** - Create a planning document (see "Planning-First Development Approach" above)
2. **Use `createPrivateTool` by default** - Only use `createTool` for public endpoints
3. Add tool definition in `server/main.ts` or domain-specific files in `server/tools/`
4. Include in `withRuntime` tools array
5. Run `npm run gen` to update external integration types
6. Start server with `npm run dev` and copy the development URL from logs
7. Run `DECO_SELF_URL=<your-dev-url> npm run gen:self` to generate self-types
8. Create TanStack Query hooks in `view/src/hooks/` to wrap RPC calls
9. Use the hooks in components instead of calling `client.YOUR_TOOL()` directly


### When Adding New Routes:
1. Create route component in `view/src/routes/`
2. Export a function that takes a parent route and returns `createRoute()`
3. Add route to router tree in `view/src/main.tsx`
4. Use TanStack Router's typesafe `createRoute` pattern

### When Adding UI Components:
1. Use shadcn CLI to add new components: `cd view && npx shadcn@latest add <component-name>`
2. Use Tailwind CSS classes for styling
3. Leverage shadcn/ui components in `view/src/components/ui/`
4. Use `clsx` and `tailwind-merge` for conditional classes
5. Use lucide-react icons for consistent iconography (already installed)

### When Working with Database:
1. **Always use `getDb(env)`** - Never create direct database connections
2. **Schema changes**: Modify `server/schema.ts` then run `npm run db:generate`
3. **Migrations**: Applied automatically when using `getDb(env)` - no manual commands needed
4. **CRUD operations**: Follow the patterns in `server/tools/` domain files (check existence before update/delete)
5. **Boolean handling**: Convert SQLite integers (0/1) to/from JavaScript booleans
6. **Error handling**: Wrap database operations in try-catch blocks
7. **Transactions**: Use `db.transaction()` for multi-step operations
8. **Types**: Leverage Drizzle's `InferSelectModel` and `InferInsertModel` for type safety

## Development Guidelines and Best Practices

### Tool Creation Defaults

**ğŸ”¥ CRITICAL: Use `createPrivateTool` by Default**

Most applications should use `createPrivateTool` instead of `createTool` for security and proper access control:

```typescript
// âœ… PREFERRED: Use createPrivateTool by default
import { createPrivateTool } from "@deco/workers-runtime/mastra";

const createMyTool = (env: Env) => createPrivateTool({
  id: "MY_TOOL",
  description: "Tool description",
  inputSchema: z.object({ /* input schema */ }),
  outputSchema: z.object({ /* output schema */ }),
  execute: async ({ context }) => {
    // Tool logic here
    return { /* result */ };
  },
});
```

**When to use `createTool` (public tools):**
- Webhook endpoints that need to be publicly accessible
- Public API endpoints for external integrations
- Tools that don't require authentication

**When to use `createPrivateTool` (default choice):**
- Internal business logic tools
- User-specific operations
- Data manipulation tools
- Most application functionality

### Database Usage Philosophy

**Not Everything Needs Database Storage**

While the template includes database capabilities, consider whether your application actually needs persistent storage:

**âœ… Good candidates for database storage:**
- User accounts and profiles
- Application-specific data that needs persistence
- Configuration settings
- Audit logs and history
- Complex relational data

**âŒ Consider alternatives to database for:**
- Simple configuration (use environment variables)
- Temporary data (use in-memory storage)
- External API data (cache in KV store or fetch on demand)
- Static content (use files or external storage)
- Session data (use JWT tokens or external session stores)

**Example: Simple counter without database:**
```typescript
// Instead of storing in database, use KV store for simple data
const createCounterTool = (env: Env) => createPrivateTool({
  id: "INCREMENT_COUNTER",
  description: "Increment a simple counter",
  inputSchema: z.object({ key: z.string() }),
  outputSchema: z.object({ count: z.number() }),
  execute: async ({ context }) => {
    const currentCount = await env.KV.get(`counter:${context.key}`) || "0";
    const newCount = parseInt(currentCount) + 1;
    await env.KV.put(`counter:${context.key}`, newCount.toString());
    return { count: newCount };
  },
});
```

### Planning-First Development Approach

**ğŸ¯ RECOMMENDED: Create Planning Documents Before Coding**

Before implementing features, create a detailed planning document that outlines:

1. **Create a planning file** (e.g., `FEATURE_PLAN.md`) with:
   - Feature requirements and user stories
   - Data models and relationships (if database is needed)
   - API endpoints and tool definitions
   - Frontend components and routes
   - Integration points with external services

2. **Follow the established patterns** from these rules:
   - Use `createPrivateTool` by default
   - Follow domain organization (max 300 lines per file)
   - Plan TanStack Query hooks for frontend integration
   - Consider whether database storage is actually needed

3. **Example planning structure:**
```markdown
# Feature: User Task Management

## Requirements
- Users can create, read, update, delete tasks
- Tasks have title, description, due date, priority
- Users can mark tasks as complete
- Tasks are private to each user

## Data Model
- Use database for task persistence (user-specific data)
- Schema: tasks table with user_id foreign key

## Tools Needed
- CREATE_TASK (createPrivateTool)
- GET_USER_TASKS (createPrivateTool)
- UPDATE_TASK (createPrivateTool)
- DELETE_TASK (createPrivateTool)

## Frontend Components
- TaskList component
- TaskForm component
- TaskItem component

## Hooks
- useCreateTask (useMutation)
- useUserTasks (useQuery)
- useUpdateTask (useMutation)
- useDeleteTask (useMutation)
```

### Authentication and Public URL Requirements

**âš ï¸ IMPORTANT: Initial Deployment Required for Authentication**

Due to OAuth callback URL requirements, you must deploy your application once before authentication will work:

1. **Initial deployment is required:**
   ```bash
   npm run deploy
   ```
   This creates a public `.deco.page` URL for your application.

2. **Authentication setup:**
   - After deployment, your app will have a public URL like `https://your-app.deco.page`
   - The login functionality at `/oauth/start` requires this public URL for OAuth callbacks
   - Local development (`npm run dev`) will NOT have working authentication until after the first deployment

3. **Development workflow:**
   ```bash
   # 1. Initial setup and development
   npm run dev  # Authentication won't work yet
   
   # 2. Deploy to get public URL
   npm run deploy  # Creates https://your-app.deco.page
   
   # 3. Continue development with working auth
   npm run dev  # Now authentication works via the public URL
   ```

4. **Why this is necessary:**
   - OAuth providers (Google, GitHub, etc.) require valid callback URLs
   - Local development URLs (localhost, deco.host tunnels) are not accepted by OAuth providers
   - The public `.deco.page` URL provides a stable callback endpoint

5. **Testing authentication:**
   - Visit your deployed app at `https://your-app.deco.page/oauth/start`
   - Complete the OAuth flow
   - Authentication state will work in both deployed and local development environments

## Environment Setup

### Prerequisites:
- Node.js >=18.0.0
- npm >=8.0.0
- Deno >=2.0.0
- Deco CLI installed: `deno install -Ar -g -n deco jsr:@deco/cli`

### Initial Setup:
1. `deco login` - Authenticate with deco.chat
2. `npm install` - Install all dependencies
3. `npm run configure` - Configure the app with the desired name and select its workspace
4. `npm run dev` - Start development
5. **`npm run deploy`** - Deploy once to enable authentication (creates public URL)
6. Continue development with `npm run dev` (authentication now works)

## Integration with Deco Platform

### Adding External Integrations:
1. Go to deco.chat dashboard
2. Add integrations (APIs, databases, etc.)
3. Run `npm run gen` to get typed interfaces
4. Use typed clients in your tools

### Deployment:
- `npm run deploy` deploys to Cloudflare Workers
- App becomes available at public URL
- Can be used as MCP server by AI agents

## Database Management

This template includes **Drizzle ORM** with **SQLite** (Cloudflare Durable Objects) for persistent data storage.

### Database Architecture

**Key Files:**
- `server/schema.ts` - Database schema definitions using Drizzle ORM
- `server/db.ts` - Database connection and migration utilities
- `server/drizzle.config.ts` - Drizzle configuration for migrations
- `server/drizzle/` - Generated migration files

### Database Connection Pattern

**ğŸ”¥ CRITICAL: Always use `getDb(env)` function**

```typescript
import { getDb } from "./db.ts";
import { eq } from "drizzle-orm";
import { myTable } from "./schema.ts";
import { createPrivateTool } from "@deco/workers-runtime/mastra";

// âœ… CORRECT: Always use getDb(env) in tools and createPrivateTool by default
export const createMyDatabaseTool = (env: Env) =>
  createPrivateTool({
    id: "MY_DATABASE_TOOL",
    description: "Interact with database",
    inputSchema: z.object({ /* input schema */ }),
    outputSchema: z.object({ /* output schema */ }),
    execute: async ({ context }) => {
      // ALWAYS get database connection this way
      const db = await getDb(env);
      
      // Perform database operations
      const result = await db.select().from(myTable);
      return { result };
    },
  });
```

**âŒ NEVER do direct database connections:**
```typescript
// DON'T DO THIS - Never create direct connections
const db = drizzle(env);  // âŒ Missing migrations
const db = new Database(); // âŒ Wrong approach
```

### Database Schema Definition

Define your schema in `server/schema.ts`:

```typescript
// server/schema.ts
import { integer, sqliteTable, text } from "@deco/workers-runtime/drizzle";

export const todosTable = sqliteTable("todos", {
  id: integer("id").primaryKey(),
  title: text("title"),
  completed: integer("completed").default(0),
});

export const usersTable = sqliteTable("users", {
  id: integer("id").primaryKey(),
  email: text("email").notNull().unique(),
  name: text("name"),
  createdAt: integer("created_at", { mode: 'timestamp' }),
});
```

### Database Operations Patterns

**1. Create (Insert):**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  const newRecord = await db.insert(myTable).values({
    title: context.title,
    completed: 0,
  }).returning({ id: myTable.id });
  
  return { id: newRecord[0].id };
}
```

**2. Read (Select):**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Select all
  const allRecords = await db.select().from(myTable);
  
  // Select with conditions
  const filteredRecords = await db.select()
    .from(myTable)
    .where(eq(myTable.completed, 1));
  
  // Select single record
  const singleRecord = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  return { records: allRecords };
}
```

**3. Update:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Check if record exists first
  const existing = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  if (existing.length === 0) {
    throw new Error("Record not found");
  }
  
  const updated = await db.update(myTable)
    .set({ title: context.newTitle })
    .where(eq(myTable.id, context.id))
    .returning();
  
  return { updated: updated[0] };
}
```

**4. Delete:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  // Verify record exists before deletion
  const existing = await db.select()
    .from(myTable)
    .where(eq(myTable.id, context.id))
    .limit(1);
  
  if (existing.length === 0) {
    throw new Error("Record not found");
  }
  
  await db.delete(myTable).where(eq(myTable.id, context.id));
  
  return { success: true, deletedId: context.id };
}
```

### Migration Workflow

**1. Schema Changes:**
```bash
# After modifying server/schema.ts
npm run db:generate  # Generates migration files
```

**2. Migration Application:**
- Migrations are **automatically applied** when using `getDb(env)`
- No manual migration commands needed in production
- Migrations run lazily on first database access

**3. Migration Files:**
- Generated in `server/drizzle/` directory
- Version controlled and deployed with your app
- Applied automatically via `migrateWithoutTransaction`

### Database Best Practices

**1. Always Use getDb():**
```typescript
// âœ… CORRECT - Every database operation
const db = await getDb(env);
```

**2. Handle Errors Gracefully:**
```typescript
execute: async ({ context }) => {
  const db = await getDb(env);
  
  try {
    const result = await db.select().from(myTable);
    return { result };
  } catch (error) {
    console.error("Database error:", error);
    throw new Error("Failed to fetch data");
  }
}
```

**3. Validate Before Operations:**
```typescript
// Always check if records exist before update/delete
const existing = await db.select()
  .from(myTable)
  .where(eq(myTable.id, context.id))
  .limit(1);

if (existing.length === 0) {
  throw new Error("Record not found");
}
```

### Database Schema Types

Drizzle automatically generates TypeScript types from your schema:

```typescript
import type { InferSelectModel, InferInsertModel } from "drizzle-orm";
import { todosTable } from "./schema.ts";

// Generated types
type Todo = InferSelectModel<typeof todosTable>;
type NewTodo = InferInsertModel<typeof todosTable>;

// Use in tool schemas
outputSchema: z.object({
  todo: z.object({
    id: z.number(),
    title: z.string().nullable(),
    completed: z.boolean(),
  }),
})
```

### Common Database Queries

**Filtering and Sorting:**
```typescript
import { eq, ne, gt, lt, and, or, desc, asc } from "drizzle-orm";

// Multiple conditions
const results = await db.select()
  .from(todosTable)
  .where(and(
    eq(todosTable.completed, 0),
    ne(todosTable.title, null)
  ))
  .orderBy(desc(todosTable.id));

// OR conditions
const results = await db.select()
  .from(todosTable)
  .where(or(
    eq(todosTable.completed, 1),
    gt(todosTable.id, 100)
  ));
```

**Joins (if using multiple tables):**
```typescript
const results = await db.select({
  todo: todosTable,
  user: usersTable,
})
.from(todosTable)
.leftJoin(usersTable, eq(todosTable.userId, usersTable.id));
```

## Common Patterns

### Error Handling:
```typescript
// In tools
execute: async ({ context }) => {
  const result = await someAsyncOperation(context);
  if (!result.ok) {
    throw new Error("...")
  }
  return result;
}
```

### Frontend State Management:
- Use `@tanstack/react-query` for server state management
- Prefer wrapping RPC client calls in TanStack Query hooks over direct calls in components
- Create custom hooks in `view/src/hooks/` for each tool:
  - Use `useQuery` for read operations (data fetching)
  - Use `useMutation` for write operations (tools that modify state)
- Use TanStack Router for typesafe navigation and routing state
- Use React hooks for component-local state

### TanStack Query Hook Patterns:

```typescript
// view/src/hooks/useTools.ts - Example comprehensive hook patterns

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// 1. Simple data fetching with useQuery
export const useGetData = (id: string) => {
  return useQuery({
    queryKey: ["data", id],
    queryFn: () => client.GET_DATA({ id }),
    enabled: !!id, // Only run when id is provided
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
  });
};

// 2. Mutation with optimistic updates and cache invalidation
export const useUpdateData = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: { id: string; value: string }) => 
      client.UPDATE_DATA(data),
    
    // Optimistic update
    onMutate: async (newData) => {
      await queryClient.cancelQueries({ queryKey: ["data", newData.id] });
      const previousData = queryClient.getQueryData(["data", newData.id]);
      queryClient.setQueryData(["data", newData.id], newData);
      return { previousData };
    },
    
    // Rollback on error
    onError: (err, newData, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(["data", newData.id], context.previousData);
      }
    },
    
    // Refetch on success
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ["data", variables.id] });
    },
  });
};


// 4. Dependent queries - only run when previous data is available
export const useUserProfile = (userId: string) => {
  return useQuery({
    queryKey: ["userProfile", userId],
    queryFn: () => client.GET_USER_PROFILE({ userId }),
    enabled: !!userId,
  });
};

export const useUserPreferences = (userId: string) => {
  const { data: userProfile } = useUserProfile(userId);
  
  return useQuery({
    queryKey: ["userPreferences", userId],
    queryFn: () => client.GET_USER_PREFERENCES({ userId }),
    enabled: !!userProfile, // Only run after user profile loads
  });
};

// 5. Infinite query for paginated data
export const useInfiniteData = (filters: any) => {
  return useInfiniteQuery({
    queryKey: ["infiniteData", filters],
    queryFn: ({ pageParam = 0 }) => 
      client.GET_PAGINATED_DATA({ ...filters, page: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextPage,
    initialPageParam: 0,
  });
};
```

### Component Usage Examples:

```typescript
// âœ… CORRECT: Using TanStack Query hooks
function DataComponent({ id }: { id: string }) {
  const { data, isLoading, error } = useGetData(id);
  const updateMutation = useUpdateData();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h2>{data?.title}</h2>
      <button 
        onClick={() => updateMutation.mutate({ id, value: "new value" })}
        disabled={updateMutation.isPending}
      >
        {updateMutation.isPending ? "Updating..." : "Update"}
      </button>
    </div>
  );
}
```

### Styling:
- Tailwind CSS for utility-first styling
- shadcn/ui components for consistent design
- Use `cn()` utility for conditional classes

## Debugging Tips

- Server logs appear in terminal during `npm run dev`
- Use browser dev tools for frontend debugging

This template provides a complete full-stack development environment for building MCP servers with modern React frontends. Focus on adding your business logic in tools while leveraging the typed RPC communication between frontend and backend.
